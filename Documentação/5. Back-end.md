> [![interação_homem_máquina](https://img.shields.io/badge/Interação_Homem_Máquina-Profa%20Eveline%20Sá-blue.svg)](url) </br>
> [![engenharia_de_software](https://img.shields.io/badge/Engenharia_de_Software-Prof%20Daniel%20Lima%20Jr-blue.svg)](url) </br>
> [![sistemas_de_informação](https://img.shields.io/badge/Sistemas_de_Informação-@IFMA-blue.svg)](url) </br>
> [![iulano_santos](https://img.shields.io/badge/Iulano_Santos-Backend%20Developer-orange.svg)](url) </br>

---

### • Aplicação do lado do Servidor (Server-side):

No backend, também conhecido como Serve-side, temos a estrutura necessária para a operação de um sistema. No nosso caso, o backend tem função também de API.

Importante sabermos o que é uma API (*Interface de Programação de Aplicações*): Conjunto de padrões, rotinas e instruções de programação que permite que softwares ou aplicativos diferentes se conectem. O uso de uma API evita que um desenvolvedor precise criar e instalar diferentes recursos para que sistemas ou aplicativos diferentes “conversem” entre si. Isso contribui para reduzir o tempo da integração e para liberar o uso da solução muito mais rápido.</br></br>
Vide abaixo a arquitetura utilizada e o papel da API no **SISGAM - Sistema de Gerenciamento de Alertas de Manutenção da EMSERF**:

<h5 align="center">
<img src="https://user-images.githubusercontent.com/40738499/169882617-c0d3360b-fa5a-4e18-827a-837453b1c921.png" width="800px" />
</h5>

Abaixo listaremos 03 principais motivos de usarmos esse recurso ao desenvolver o produto do cliente EMSERF:

- **Segurança**: as APIs são seguras, pois criam uma espécie de barreira que permite acesso apenas às informações que fazem parte daquela aplicação, e não ao sistema por inteiro.
- **Menor volume de dados**: considerando que cada API é específica para determinada função, são inseridos no sistema apenas os dados que realmente são necessários para a ação esperada.
- **Aumento da eficiência de sistemas e aplicativos**: as APIs contribuem para melhorar a performance de sistemas, sem que seja preciso iniciar processos de desenvolvimento que levem a esse resultado do zero.

---
### Iniciando a construção do Backend:
Para que o backend funcione em uma aplicação web, é necessário um serviço de roteamento e que sobretudo seja capaz de simular o funcionamento de um servidor web. Sendo assim, devemos importar o respectivo pacote com essas propriedades. A partir da nossa App Desktop, vamos subir um servidor Web e assim abrir um socket com uma porta que recebe requisições:

    npm install express --save


Para importar pacotes usamos a palavra chave "require". Após instalar um pacote, a qualquer momento podemos carregá-lo. A sequência é essa, instalar o pacote e carregá-lo em momento oportuno. De forma mais elegante, podemos guardar a require em uma constante, ou seja guardar a referência para o pacote.

Vamos então criar o folder "src" e o file "index.js":

    const express = require('express');

    function main(){
        console.log("SISGAM");
    }
    main

---
### Definindo o protótipo da primeira rota no backend:
Em seguida, vamos chamar a função principal na variável "app", e esta passará a ter os recursos do express.
E dessa forma "app" passa a ser usado em "main". Sendo assim, passamos a criar uma action e por conseguinte,
devemos setar sua rota:

    const express = require('express');
    const app = express();

    function main() {
        app.get('/', function (req, res) {
            res.send("SISGAM")
        }
        )
    }
    main


---
### Definindo a porta de comunicação do serviço:
Sempre que um pacote de dados for enviado, "app" usa o protocolo HTTP, que por sua vez, roda em cima do TCP. Sendo assim, 
envia-se bytes pra uma determinada porta da aplicação de quem está escutando a request. Todo cliente que quer escutar uma 
conexão remota precisa de uma porta TCP, e o próprio protocolo TCP designa portas para alguns softwares (Ex: React, 3001).

Existe um método de "app" chamado "listen", e quando a resquest é feita é obrigatório passar a porta:

        const express = require('express');
        const app = express();
        const port = 3000;
        
        function main() {
            app.get('/', function (req, res) {
                let a = 3; 
                let b = 2;
                //console.log("Resultado: " + c) //Output API Console;
                res.send((a+b).toString()); //Output Console Client (Postman or Browser);
            })

            app.listen(port, () => {
                console.log(
                    `Olá @EMSERF, o SISGAM App está ouvindo na porta: ${port}`
                    ) //Output API Console;
            });
        }

        main();


---
### Subindo o Backend para primeiro teste: 
Abra o shell, execute o comando abaixo e verifique no console se a saída é a esperada:

        node index.js


---
### Criando um arquivo de configuração:

Avançando, vamos criar o nosso arquivo de configuração em texto, que simula um ambiente de execução.
Ou seja, as variáveis dele sobrescrevem as variáveis de produção. Então podemos usá-lo conforme ambiente
(produção, teste, etc). O pacote usado para gerenciar esse processo é o dotenv:

        npm install dotenv
        

Em todo arquivo que formos usá-lo, vamos chamá-lo no cabeçalho de index, vide abaixo a sintaxe ideal:

        require('dotenv').config({path: 'config.env'});


Em seguida, criamos o file "config.env" no folder "src":

---
### Prototipando rotas e controllers (Topdown):

As rotas precisam ser registradas antes da aplicação ouvir. Logo, além de definí-las, é necessário exportá-las.
As actions efetivamente, são feitas por Controllers. Criamos então folder "controller" + file "campuscontroller.js".
Após, devemos importar a controller em routes, a essa altura o seu verbo HTTP também já precisa estar definido:

##### route:


##### controller:
        

O programador, ao documentar a reação da API durante requisições HTTP, usa o 'Index' pra "logar" o feedback no console da API e
a 'Controller' para "logar" no console do cliente.


### Definindo Models + Tratamento de Exceções Controller:

O tratamento de exceções consiste em cercar de todas as formas, possíveis erros durante as resquisições.
Quando passamos um parâmetro em uma request, certamente, estamos buscando recuperar dados para o cliente. 
Daí vem a  necessidade de criarmos a classe de "Models", que farão as devidas consultas SQL no banco de dados. A responsabilidade das Models, é trazer à tona os dados do negócio.

*Criamos o folder "repository", com o file "BancoDeAlertasEMSERF.js", contendo as variáveis de ambiente do Node.js que 
permitam a conexão com o banco de dados.*
*Criamos então o folder "model" e o file "xxxxxxx".*

Abaixo temos um exemplo de Model e Controller, com as exceções de request devidamente tratadas e comentadas (Try Catch).*


*Model xxxxxxx*


Nas configurações do Banco de Dados MySQL, usaremos então uma interface para um conector oficial do MySQL.
No caso, é o @mysql/xdevapi, vide abaixo comando de instalação:

        npm install @mysql/xdevapi --save --save-exact;
        
**Importante sempre dar o comando de install na root do projeto, para que ele possa achar o Package-json**



---
